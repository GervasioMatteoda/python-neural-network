# -*- coding: utf-8 -*-
"""
python-convolutional-neural-network.ipynb
Automatically generated by Colaboratory.
"""

# Importar las Librerías
import numpy as np
import tensorflow as tf
import tensorflow_datasets as tfds
from tensorflow.keras.datasets import mnist
from tensorflow.keras.utils import to_categorical
from tensorflow.keras.preprocessing.image import ImageDataGenerator

# Definición de Variables
TAM_IMAGEN = 28
NRO_EPOCAS = 30
TAM_LOTE = 32
CANT_NEURONAS = 125
TAM_SALIDA = 10

# - - - - - - - - - - - - - - - -
rango_rotacion = 30
mov_ancho = 0.25
mov_alto = 0.25
rango_inclinacion = 15
rango_acercamiento = [0.5, 1.5]
# - - - - - - - - - - - - - - - -

# Descargar el Set de Datos & Obtener Variables
(px_entrenamiento, etq_entrenamiento), (px_pruebas, etq_pruebas) = mnist.load_data()

# Modificación de Datos ~ One-Hot Enconding, Datos Flotantes & Normalizar
px_entrenamiento = px_entrenamiento.reshape(px_entrenamiento.shape[0], 28, 28, 1)
px_pruebas = px_pruebas.reshape(px_pruebas.shape[0], 28, 28, 1)

# Aplicar One-Hot Encoding
etq_entrenamiento = to_categorical(etq_entrenamiento)
etq_pruebas = to_categorical(etq_pruebas)

# Convertir a Flotante & Normalizar
px_entrenamiento = px_entrenamiento.astype('float32') / 255
px_pruebas = px_pruebas.astype('float32') / 255

# Aumento de Datos
rango_rotacion = 30
mov_ancho = 0.25
mov_alto = 0.25
rango_inclinacion = 15
rango_acercamiento = [0.5,1.5]

datagen = ImageDataGenerator(
    rotation_range = rango_rotacion,
    width_shift_range = mov_ancho,
    height_shift_range = mov_alto,
    zoom_range=rango_acercamiento,
    shear_range=rango_inclinacion
)

datagen.fit(px_entrenamiento)

# Crear el Modelo
modelo = tf.keras.models.Sequential([
    tf.keras.layers.Conv2D(32, (3,3), activation='relu', input_shape=(TAM_IMAGEN, TAM_IMAGEN, 1)),
    tf.keras.layers.MaxPooling2D(2, 2),

    tf.keras.layers.Conv2D(64, (3,3), activation='relu'),
    tf.keras.layers.MaxPooling2D(2,2),

    tf.keras.layers.Conv2D(128, (3,3), activation='relu'),
    tf.keras.layers.MaxPooling2D(2,2),

    tf.keras.layers.Dropout(0.5),
    tf.keras.layers.Flatten(),

    tf.keras.layers.Dense(CANT_NEURONAS, activation='relu'),
    tf.keras.layers.Dense(TAM_SALIDA, activation="softmax")
])

# Compilar el Modelo
modelo.compile(optimizer='adam', loss='categorical_crossentropy', metrics=['accuracy'])

# Generador de Imágenes para el Entrenamiento
datos_generados_entrenamiento = datagen.flow(px_entrenamiento, etq_entrenamiento, batch_size = TAM_LOTE)

historial = modelo.fit(
    datos_generados_entrenamiento,
    epochs = NRO_EPOCAS,
    batch_size=TAM_LOTE,
    validation_data = (px_pruebas, etq_pruebas),
    steps_per_epoch = int(np.ceil(60000 / float(TAM_LOTE))),
    validation_steps = int(np.ceil(10000 / float(TAM_LOTE)))
)